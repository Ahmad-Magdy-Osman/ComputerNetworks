Fiber, copper, radio -> 
HTTP -> 
Host -> 
NAT -> 
Router -> 
Service -> 
Skype -> VoIP
TCP -> 
Transmission rate -> 
UDP -> 

Order of Protocols Layers
    Application Layer -> Emails, browsers
    Transport Layer -> Data coming in, packets
    Network Layer -> Lan, WiFi
    Link Layer -> Take tyhat message into 
    Physical Layer -> The actual physical stuff

Wireshark -> Packet sniffer

Protocal Encapsulation - Right to Left
    PhysicalSignal|LL|Net|Tran|AppMsg|Checksum(CRS)

Loopback

The initiation between the client and server connection is called three handshake

                                                    September 12
What are three ways to deal was too many requests:
    1-Ignore
    2-Add power -> 2.5-Load balance
    3-Optimize code (too expensive)

P2P works well for load balancing.

A - IPv4 - 32 bit - 2^32 ~ 4.10^9

AAAA - IPv6 - 128 bit

MX

NS

nslookup -type=AAAA luther.edu for example.

DNS is the top layer protocol, if i go to test.mit.edu, it asks edu zone for more ip info, then the mit for its server ip, then test for its server ip too.

How many ports are there: 2^16 = 65536

In HTTP / DNS messages:
    HTTP / DNS         => Application
    TCP /  UDP         => Transport
    IP          => Network
    Ethernet    => Link
    Wired/WiFi  => Physical
A messeage response is as follows

Ethernet Header - IP Header - UDP Header - DNS MSG
Type:x0800        Porto:x11 - port:53
Messeage for IP   means udp - means port 53 for DNS messages

    The message on a lower level gives informtion about the higher level protocol request

Conversion from Binary to Hexadecimal to Decimal.

The three way handshake are 3 messages in TCP after the DNS message. There are threeway handshake at the termination too.

The messages from TCP for example are transport-layer higher level messages. It is not necessary for messages to happen on the Application layer, it can even happen on the network/link layers too.

Local cache, then the gateway, then cache on the proxy server, then some stuff on a CDN(content delivery network, for like Netflix), and then data from the servers.

For email exchange protocols, you either use pop3 and smtp or imap and smtp.

----
project 2

python3 resolve.py A website dns

python3 -m pytest -v test_solver.py

test fb.com where only one response
test yahoo.com for six different responses

----

Base 10 -> 10 digits
Octal, base 8, from 0 to 7, then 10 to 17, then 20 to 27
Hexadecimal, base 16, from 0 to 9 and then A to F. Then 10 happens, to 1F, for example hex(28) gives 1c.
Binary, 0 and 1. 0, 1, 10, 11, 

For bits, its either Big Endian or Little Endian.

Bit ^ 2 from the right to left.

0, 1, 10, 11, 100, 101, 110, 111, 1000

430 base of 10 to binary base 2 = 110101110 -> Do it by hand or TI
binary to decimal. 

430 = 4 * 10^2 + 3 * 10^1 + 0 * 10^0

110101110 base 2 = 1 * 2^8 + 1 * 2^7 + 1 * 2^6... From right to left the bits are 8 to 0.

110101110 base 2 is equal 1AE in base 16. for the 16 digits in Hexadecimal, there are only 4 binary digits, 4 bits, needed for it. So do it as following
1 1010 1110 => 
1   A   E

Would apply from octal or hexadecimal to binary and otherwise. The highest needed for octal is 111, since 8 digits from 0 to 7. So three binary digits for each octal number, and do it from the right to left, same as in how hexadecimal's work.

binary addition

110101110
100001001

1010110111

----------

negative numbers in binary, follow the one's compliment rule where the left most bits are given a flag that these numbers are one's compliment and they're basically the flipped bits for the same number

110101110 would base
001010001 in one's compliment, in order to be neagtive.

two's compliment, you just add one, to the one's compliment.

001010001 would be
001010010

have a trueth table of 
x | y | x&y | x|y | x^y

right shift >> for binary, left shift <<

to multiple a number by 2, shift it to the left one position
to divide it by 2, shift it to the right one position

google bits extraction

the & operator and xor to be google

the & operator is litteraly both either true or false

to extract three bits from 10101110
                           00000111
                    do & on.    110

extract the left ones, you do a shift after the and operator

----------------------

IPV6: '{:04x}'.format(0x2001)
':'.join()

-----------------------

ARP -> Address Resolution Protocol, works at the local level to resolve IPv4 to an ethernet, MAC, address.
DNS -> Domain Name System, takes domain name and resolves that into IP
FTP -> File Transfer Protocol, files over TCP(Transmission Control Protocal)
HTTP -> Web Documents, over TCP
HTTPs -> Web Documents, Securely, over TCP
ICMP -> Send and receive network control messages => ICMP Internet Control Message Protocol -> Belongs to the Network Layer Level
IMAP -> Manipulates emails on the server
POP3 -> Reterival
SMTP -> Sending - also it is used in transfering emails between the servers
TFTP, Trivial File Transfer Protocol -> Transfer large files over the UDP

-----------------------

Exam
    Package Analysis - True or False - WHy?
    Understand DNS Message Format

-----------------------

UOP  MSG Size

-----------------------

Homework 5

Look at the picture

python3
    chk_pseudo = 0x7f00 + 0x0001 + 0x7f00 + 0x0001 + 0x0011 + 0x000c + 
    hex(chk_pseudo)
    OUTPUT: 0xfe1f

That is what we Wireshark gives due to UDP checksum offload

    chk_udp = 0xd173 + 0x10cc + 0x000c + 0x0000
    hex(chk_udp)
    OUTPUT: 0xe24b

    chk_data = 0x546f + 0x676f
    hex(chk_data)
    OUTPUT: 0xbbde

    chk_full = chk_pseudo + chk_udp + chk_data
    hex(chk_full)
    
    bin(chk_full)

pictures for dealing with the overflow of the binary values and then doing ones compliment

the bin representation, has two more extra bits, you take however many on the left of extra bits, and add them to the right most sixten bits, and then do the ones compliment.

the CHKSUM 2 bytes in wireshark have to be zerod out

Datagram = UDP + Data

The chksum happens on multiple levels because there are multiple sources of errors, including losing data at the wires level, which is why the chksum happens at the Ethernet level, howver, it is not perfect. IPV4 checks for the header chksum and leaves the rest for the transportation layer, and in IPv6 it was removed and left for the transportation layer. Ethernet is very old, and at the same time it is quite fast, so we are not losing anything by leaving it here. Between checksum over ethernet and over the transportation layer, we know we will catch any errors.

QUIC: google QUIC cloudfare

------------------------------------

UDP - 8 Bytes
TCP - 20 Bytes
IPv4 - 20 Bytes
IPv6 - 40 Bytes
Ethernet - 14 Bytes

Frame = Ethernet + IP + UDP(transportation) + MSG
IP = IP + UDP(transportation) + MSG
Dataframe -> UDP(transportation) = UDP(transportation) + MSG
MSG = MSG

------------------------------------

The use of & | ^ << >>

Between ifconfig and ip, ip is more powerful - between nslookup and dig, dig is more powerful and important!

ipconfig, ping, nslookup

those are enough tools for networking: ip - mtr - dig - netstat

mtr -> a specfic route to other routers

netstats -> open ports on your machine

arp -> 

------------------------------------

What type of delays do we have?
    Congestion - Probogtational - Distance
    Transmission delays -> how fast can the ethernet device move data

    The answer for calculating delays should be in seconds.

    Kilobps -> 10^3
    Megabps -> 10^6
    Gigabps -> 10^9
    Terabps -> 10^12

    10 mbps to convert to bits should be done with 10 to the power of 6.

    throughput -> bits/seconds to calculate

TCP and UDP do not do error correction, but rather error detection, using the checksum, and it can try to figure it out. Retransmition for TCP is not error correction.

hello2e104

2 for number of vowels, 1 and 4 for their indices, and then error detection try to fix them.

For the three-way handshake, the third message can combine data too with it!

If only the three-way handshake happen and nothing else being sent, the server is gonna wait for a abit until timeout. This is how an attack can happen, exhaust the network with a lot of three-way handsahake and exhaust the machine with bogus requests.

At the transportation layer, all the packets or segments are over the same zie, 64kilobytes, despite how much the application is sending. So 64kb, gets sent. That is what the timeout considers, and timeout depends also on the distance, the history of transmissions, etc...

----
Exam will be on packet analysis and calculations. -> Mostly what we did on Homework 5.
----

To transmit data reliability and quickly, we divide the data into larger chunks of packets, send one chunk, and see if that got sent, if not we resent. Round-trip-time is what we look at here, we're trying to minimize that. This is not so great because if this large chunk of packets gets lost or needed to be retransmitted, then we're actually losing on the efficiency part here.

However, we still do it that way, and we have an assumption that we won't face a problem, however, if some problem occurs, we'll see how to solve it. Pipelining is the name of this. How we fix this, is the point of TCP and other reliable protocols to answer.

Mutliple packets are being sent over the same connection.

So we do packets into chunks, and then do pipelining to send multiple chunks at the same time. If a chunk in between gets lost, like in my "humiliating" exercise, everything from and beyond that lost chunk will be retransmitted. The order will be depend on "sequence number", starting with 0 or 1 and up to whatever needs to be transmitted.

One of the problems of pipelining is, if one packet is delayed, ten packets can be retransmitted.

Know the difference, for yourself, For Fragmentation, Segementation, P2P data division on Application Layer.

Pipelining works with timeouts for each packet.

Why do we use TCP instead of UDP? What errors do TCP fix? UDP does not do retransmission. The retransmission happening on the DNS layer, in case of failure, happened on the Application layer, so UDP did not do the retransmissions for us. 
TCP takes care of retransmissions for us, it also makes sure that all packets flow smoothly, that the sender and the receiver agree on a certain speed so the client and the server do not overflow each other; flow control. TCP takes care of the three-way handshake. 
TCP is very convenient for the Applications, it is complicated, but makes it convenient. 

TCP 
    Point-to-point: process to process communication, not one-to-many.
    Reliable byte stream: retransmissions.
    TCP is pipeline: multiple data chunks bein sent
    Full duplex: both client and server can send and receive data.
    Connection-oriented: three-way handshake, unlike UDP
    Flow control: the client and the server deciding the speed and it is a way to slow down the other party. The receiver cannot process data that fast, so it is slowing the sender.
    Congestion control: There is a problem in the netowork, so an intermiedate, probably the router, will slow down the sender.
    Both Congestion control and Flow control will slow the sender speed.

App is responsible for the Application Layer
OS is responsible for Transmission and Network Layer
Driver is response for the Ethernet(NIC: Network Interface Card) layer

Ask Dr. Roman about large TCP pagckets again 

In packet analysis, to know if a file is being downloaded or uploaded, look at POST and GET, or see who is acknowlging, if the server is acknowlging, then you are uploading.

Alice in the Wonderland

Read about Syn -> Ack, Syn -> Ack -> DATA, DATA, DATA...

Relative sequence number starts from 0, while the real sequence number is a random number that is randomly generated between the sender and receiver. You can uncheck the relative one in the preference and add a column. You can figure out the real number by looking at the bytes in the wireshark.

The random sequence number is chosen so that each session is taken care of. Because if two sessions start at 0, and both are stoped at ten, and then packet eleven is sent, which session is that?

Calculating throughput can be done by adding length and then dividing by the time of the last http packet(the last meaningful packet): total bytes / time.

It was not closed properly. Look at a FIN packet.

200 Response code, the file was transmitted successfully. 

----

UDP, TCP, and DNS headers for exam

Ask Dr. Roman about checksum calculation. Also the state.

----

TCP Reno is the version we care about

Congestion Control on TCP

Congestion Control is the thing that differentiate between UDP and TCP

We have Flow Control and Congestion Control

Flow Control is the receiver to tell the sender to slow down -> Mason telling Roman to slow down because he is taking notes
Congestion Control is the ability of the sender to figure that the data is not getting received -> Roman slowing down because he is figuring people are are kinda of getting lost

How can the sender limit the traffic rate?
    Increase time between packets -> send fewer packets per time unit

How can sender perceivee there is congestion?
    Congestion Indicators
        Timeout
        3 duplicate acks

    There is too much data for a router to process and the router will have a limitted buffer to process and if the amount of packets exceeded that buffer, we will drop them. The router has a queue buffer. Think about "is on friday" packets message, where you will ask for what is on friday, three times as three words were received, and then once you have what is on friday, you do not ask for "is on friday" again but rather what is after.
    Also, a packet is dropped if the packet is corrupted. 

Solutions to Congestion Control
    Slow Start
    Congestion avoidance

Reno and Taheo will both go down to one segment in case of timeout

---------

Calculations and Packet Analysis
    Numbering Systems
    UDP - TCP - DNS

Base 5 to base 7 is base 5 to base 10 and base 10 to base 5

2^16

bits/second

Throughput calculations
Delays calculations

The whole packet given, and then asks about some values.

The values in the UDP/DNS header. Maybe TCP.

Checksum of 4 Bytes
    Four hexadecimal numbers
        convert to binary
        return to hexadecimal

Hexadecimal to binary
    Pictures

A question about the states of the TCP
    State Diagram of TCP

Port numbers for matching questions
    The services we have seen so far: the protocols are on the slides

Wireshark screenshots in time and bytes for the throupput calculators

In the networking world, its always a power of 10 -> Kbps = 1000 bits per second, Mbps = 1000000 bits per second

Sequence number + number of bytes 

Tools and their usages

----------------

The router has a very  simple decision of who to send this packet to
    Called forwarding
        Moving the packet within the router(from one input interface to another)
            A router can be quite big with dozens of ports
    This decision has to happen within nanoseconds or one, two microseconds at most
        This includes the execution

Routing algorithm

THe data get queued in the router, and if there is congestion and timeout, packets will start getting dropped.

IPv4: 2^32
IPv6: 2^128

---

Project 5:
    Pay special attention to "Select" lines

HW9, Question 5:
    The question to the first two, should be the same.
    Zero(?)

3,2,3

ICMP - Internet Control Messaging Protocal
    Report back something

Question about Layers on the second exam

IPV4 header

MTU -> Max Transit Unit, depends on the link layer technology, and is basically how much you're allowed to send between two routers.

Each router can have its own max fragment Size.

    Routers do fragmentation, but do not do defragmentation.

    IPv4 makes fragmentation the router's problem, while IPv6 made that problem on the machine level (still network layer), before reaching the router.

255.255.255.255 -> Broadcasting IP, you send out to everybody on the local newtwork to fgiure out the ip address for you after booting for example. 

A subnet with multiple switches can show that switches have multiple interfaces to deal with other switches and the machines' networks. 

What matters in IPs is the last number. Like how Luther is assigned 72.207.32.0 to 72.207.64.255. The first two are the network prefix and the second two are host address. Luther is given 19 bits of network prefix and 13 for host address. 

    The number of possible addresses 2^13 
        Two are very special addresses making the possible address to for hass address 
            2^13 -2 possible addresses
        the number of bits available for hos addresses, when filled with 0s, makes it the network address
        the number of bits available for host addresses, when filled with 1s, makes it local broadcasting
    
Masks are assigned
    Masks are used to do and bitwise operation on and extract the network prefix. This helps the router figure which route. The masks are assigned by ISP.
