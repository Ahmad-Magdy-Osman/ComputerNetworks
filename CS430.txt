Fiber, copper, radio -> 
HTTP -> 
Host -> 
NAT -> 
Router -> 
Service -> 
Skype -> VoIP
TCP -> 
Transmission rate -> 
UDP -> 

Order of Protocols Layers
    Application Layer -> Emails, browsers
    Transport Layer -> Data coming in, packets
    Network Layer -> Lan, WiFi
    Link Layer -> Take tyhat message into 
    Physical Layer -> The actual physical stuff

Wireshark -> Packet sniffer

Protocal Encapsulation - Right to Left
    PhysicalSignal|LL|Net|Tran|AppMsg|Checksum(CRS)

Loopback

The initiation between the client and server connection is called three handshake

                                                    September 12
What are three ways to deal was too many requests:
    1-Ignore
    2-Add power -> 2.5-Load balance
    3-Optimize code (too expensive)

P2P works well for load balancing.

A - IPv4 - 32 bit - 2^32 ~ 4.10^9

AAAA - IPv6 - 128 bit

MX

NS

nslookup -type=AAAA luther.edu for example.

DNS is the top layer protocol, if i go to test.mit.edu, it asks edu zone for more ip info, then the mit for its server ip, then test for its server ip too.

How many ports are there: 2^16 = 65536

In HTTP / DNS messages:
    HTTP / DNS         => Application
    TCP /  UDP         => Transport
    IP          => Network
    Ethernet    => Link
    Wired/WiFi  => Physical
A messeage response is as follows

Ethernet Header - IP Header - UDP Header - DNS MSG
Type:x0800        Porto:x11 - port:53
Messeage for IP   means udp - means port 53 for DNS messages

    The message on a lower level gives informtion about the higher level protocol request

Conversion from Binary to Hexadecimal to Decimal.

The three way handshake are 3 messages in TCP after the DNS message. There are threeway handshake at the termination too.

The messages from TCP for example are transport-layer higher level messages. It is not necessary for messages to happen on the Application layer, it can even happen on the network/link layers too.

Local cache, then the gateway, then cache on the proxy server, then some stuff on a CDN(content delivery network, for like Netflix), and then data from the servers.

For email exchange protocols, you either use pop3 and smtp or imap and smtp.

----
project 2

python3 resolve.py A website dns

python3 -m pytest -v test_solver.py

test fb.com where only one response
test yahoo.com for six different responses

----

Base 10 -> 10 digits
Octal, base 8, from 0 to 7, then 10 to 17, then 20 to 27
Hexadecimal, base 16, from 0 to 9 and then A to F. Then 10 happens, to 1F, for example hex(28) gives 1c.
Binary, 0 and 1. 0, 1, 10, 11, 

For bits, its either Big Endian or Little Endian.

Bit ^ 2 from the right to left.

0, 1, 10, 11, 100, 101, 110, 111, 1000

430 base of 10 to binary base 2 = 110101110 -> Do it by hand or TI
binary to decimal. 

430 = 4 * 10^2 + 3 * 10^1 + 0 * 10^0

110101110 base 2 = 1 * 2^8 + 1 * 2^7 + 1 * 2^6... From right to left the bits are 8 to 0.

110101110 base 2 is equal 1AE in base 16. for the 16 digits in Hexadecimal, there are only 4 binary digits, 4 bits, needed for it. So do it as following
1 1010 1110 => 
1   A   E

Would apply from octal or hexadecimal to binary and otherwise. The highest needed for octal is 111, since 8 digits from 0 to 7. So three binary digits for each octal number, and do it from the right to left, same as in how hexadecimal's work.

binary addition

110101110
100001001

1010110111

----------

negative numbers in binary, follow the one's compliment rule where the left most bits are given a flag that these numbers are one's compliment and they're basically the flipped bits for the same number

110101110 would base
001010001 in one's compliment, in order to be neagtive.

two's compliment, you just add one, to the one's compliment.

001010001 would be
001010010

have a trueth table of 
x | y | x&y | x|y | x^y

right shift >> for binary, left shift <<

to multiple a number by 2, shift it to the left one position
to divide it by 2, shift it to the right one position

google bits extraction

the & operator and xor to be google

the & operator is litteraly both either true or false

to extract three bits from 10101110
                           00000111
                    do & on.    110

extract the left ones, you do a shift after the and operator

----------------------

IPV6: '{:04x}'.format(0x2001)
':'.join()

-----------------------

ARP -> Address Resolution Protocol, works at the local level to resolve IPv4 to an ethernet, MAC, address.
DNS -> Domain Name System, takes domain name and resolves that into IP
FTP -> File Transfer Protocol, files over TCP(Transmission Control Protocal)
HTTP -> Web Documents, over TCP
HTTPs -> Web Documents, Securely, over TCP
ICMP -> Send and receive network control messages => ICMP Internet Control Message Protocol -> Belongs to the Network Layer Level
IMAP -> Manipulates emails on the server
POP3 -> Reterival
SMTP -> Sending - also it is used in transfering emails between the servers
TFTP, Trivial File Transfer Protocol -> Transfer large files over the UDP

-----------------------

Exam
    Package Analysis - True or False - WHy?
    Understand DNS Message Format

-----------------------

UOP  MSG Size

-----------------------

Homework 5

Look at the picture

python3
    chk_pseudo = 0x7f00 + 0x0001 + 0x7f00 + 0x0001 + 0x0011 + 0x000c + 
    hex(chk_pseudo)
    OUTPUT: 0xfe1f

That is what we Wireshark gives due to UDP checksum offload

    chk_udp = 0xd173 + 0x10cc + 0x000c + 0x0000
    hex(chk_udp)
    OUTPUT: 0xe24b

    chk_data = 0x546f + 0x676f
    hex(chk_data)
    OUTPUT: 0xbbde

    chk_full = chk_pseudo + chk_udp + chk_data
    hex(chk_full)
    
    bin(chk_full)

pictures for dealing with the overflow of the binary values and then doing ones compliment

the bin representation, has two more extra bits, you take however many on the left of extra bits, and add them to the right most sixten bits, and then do the ones compliment.

the CHKSUM 2 bytes in wireshark have to be zerod out

Datagram = UDP + Data

The chksum happens on multiple levels because there are multiple sources of errors, including losing data at the wires level, which is why the chksum happens at the Ethernet level, howver, it is not perfect. IPV4 checks for the header chksum and leaves the rest for the transportation layer, and in IPv6 it was removed and left for the transportation layer. Ethernet is very old, and at the same time it is quite fast, so we are not losing anything by leaving it here. Between checksum over ethernet and over the transportation layer, we know we will catch any errors.

QUIC: google QUIC cloudfare

------------------------------------

UDP - 8 Bytes
TCP - 20 Bytes
IPv4 - 20 Bytes
IPv6 - 40 Bytes
Ethernet - 14 Bytes

Frame = Ethernet + IP + UDP(transportation) + MSG
IP = IP + UDP(transportation) + MSG
Dataframe -> UDP(transportation) = UDP(transportation) + MSG
MSG = MSG

------------------------------------

The use of & | ^ << >>

Between ifconfig and ip, ip is more powerful - between nslookup and dig, dig is more powerful and important!

ipconfig, ping, nslookup

those are enough tools for networking: ip - mtr - dig - netstat

mtr -> a specfic route to other routers

netstats -> open ports on your machine

arp -> 

------------------------------------

What type of delays do we have?
    Congestion - Probogtational - Distance
    Transmission delays -> how fast can the ethernet device move data

    The answer for calculating delays should be in seconds.

    Kilobps -> 10^3
    Megabps -> 10^6
    Gigabps -> 10^9
    Terabps -> 10^12

    10 mbps to convert to bits should be done with 10 to the power of 6.

    throughput -> bits/seconds to calculate

TCP and UDP do not do error correction, but rather error detection, using the checksum, and it can try to figure it out. Retransmition for TCP is not error correction.

hello2e104

2 for number of vowels, 1 and 4 for their indices, and then error detection try to fix them.

For the three-way handshake, the third message can combine data too with it!

If only the three-way handshake happen and nothing else being sent, the server is gonna wait for a abit until timeout. This is how an attack can happen, exhaust the network with a lot of three-way handsahake and exhaust the machine with bogus requests.

At the transportation layer, all the packets or segments are over the same zie, 64kilobytes, despite how much the application is sending. So 64kb, gets sent. That is what the timeout considers, and timeout depends also on the distance, the history of transmissions, etc...
